---
created: 2025-08-12T00:19:38-07:00
---

I want to use the `Export selected scene (and dependencies)` option in Godot more, but it doesn't know how to detect dependencies in scripts. I was able to work around this problem by including the script dependencies as a variable with `@export_storage`:

```
## Automates a [Vector2] value.
class_name AutoVector2
extends Auto

## This only exists to help Godot detect the parent class dependency.
@warning_ignore("unused_private_class_variable")
@export_storage var _parent_class = preload("uid://v7mw8c6osahd")

# elided
```

`@export_storage` is used to hide the variable from being edited in the inspector. However, this makes the `.tscn` and `.tres` files more noisy. Also, if I ever need to update these dependencies, all existing resources will not have the dependencies automatically updated! They would instead still have the old list of dependencies. It would be nice if this could be done automatically to avoid both of these problems

It wouldn't be a perfect solution, but just figuring out how to make just parent class dependency detection work would address my needs since that's all I need it for. I'm trying to see if I can work around this problem by using the `EditorExportPlugin`:

```gdscript
@tool
extends EditorExportPlugin

func _get_name() -> String:
    # We start with an "A" in order to have this plugin run before the
    # GDScriptExportPlugin, which converts ".gd" files into .gdc files.
    # See: https://github.com/godotengine/godot/issues/93487#issuecomment-2184192713
    return "A.space.exodrifter.deps"

func _export_file(path: String, type: String, features: PackedStringArray) -> void:
    if type == "GDScript":
        print(path)
        var script: GDScript = load(path)

        # Add the base script as a dependency
        var base := script.get_base_script()
        if is_instance_valid(base):
            var bytes := FileAccess.get_file_as_bytes(base.resource_path)
            add_file(base.resource_path, bytes, false)

            # Godot won't recurse for us, so do it manually.
            _export_file(base.resource_path, "GDScript", features)
```

However, this does not work, because the scripts are exported as `.gd` instead of as `.gdc`. It looks like this doesn't add the script to the list of scripts to compile.

So, I thought maybe if I edited the resource file to have the base script as another resource, that might work:

```gdscript
@tool
extends EditorExportPlugin

func _get_name() -> String:
	# We start with an "A" in order to have this plugin run before the
	# GDScriptExportPlugin, which converts ".gd" files into .gdc files.
	# See: https://github.com/godotengine/godot/issues/93487#issuecomment-2184192713
	return "A.space.exodrifter.deps"

func _get_customization_configuration_hash() -> int:
	# No idea what Godot wants us to return here, hopefully this works since we
	# want to do the same thing regardless of export configuration.
	return "space.exodrifter.deps".hash()

func _begin_customize_resources(_platform: EditorExportPlatform, _features: PackedStringArray) -> bool:
	return true

func _customize_resource(resource: Resource, path: String) -> Resource:
	if resource is GDScript:
		resource.set_meta("_dep_base", resource.get_base_script())
	return resource
```

...but this seemed to have no effect as well.

It might be true that by the time any custom `EditorExportPlugin` is run, the list of scripts to compile has already been decided and there's no way for me to edit that list.
